
O(1) constant time

    입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘
    F(int n){
        return (n[0] == 0)?true:false;
    }
    데이터가 증가해도 성능에 변함이 없다

    time(데이터처리시간)
    ^
    |
    |____________
    |
    -------------> data(데이터크기)

*******************************************************************

O(n) linear time

    F(int[] n){
        for i = 0 to n.length
            print i
    }

    입력 데이터의 크기에 비례해서 처리시간이 걸리는 알고리즘
    n의 크기만큼 처리시간이 걸린다
    데이터가 증가함에 따라 처리시간도 같이 증가함
    데이터와 시간이 같은 비율로 증가

    time(데이터처리시간)
    ^          *
    |       *
    |    *
    | *
    -------------> data(데이터크기)

*******************************************************************

O(n2) quadratic time

    F(int[] n) {
        for i = 0 to n.length
            for j = 0 to n.length
                print i + j;
    }
     |----- n -----|
    -
    |   ㅁ ㅁ ㅁ ㅁ ㅁ
    |   ㅁ ㅁ ㅁ ㅁ ㅁ
    n   ㅁ ㅁ ㅁ ㅁ ㅁ
    |   ㅁ ㅁ ㅁ ㅁ ㅁ
    |   ㅁ ㅁ ㅁ ㅁ ㅁ
    _
    time(데이터처리시간)
    ^           *
    |          *
    |       *
    | *
    -------------> data(데이터크기)

*******************************************************************

O(nm) quadratic time
    F(int[]n, int[]m) {
        for i = 0 to n.length
            for j = 0 to m.length
                print i + j;
    }
    |----- n -----|
    -
    |   ㅁ ㅁ ㅁ ㅁ ㅁ
    m   ㅁ ㅁ ㅁ ㅁ ㅁ
    |   ㅁ ㅁ ㅁ ㅁ ㅁ
    _
    time(데이터처리시간)
    ^           *
    |          *
    |       *
    | *
    -------------> data(데이터크기)

*******************************************************************
O(n3) polynomial/ cubic time
    F(int[] n){
        for i = 0 to n.length
            for j = 0 to n.length
                for k = 0 to n.length
                    print i + j + k;
    }
    큐브모양
    time(데이터처리시간)
        ^      *
        |     *
        |    *
        | *
        -------------> data(데이터크기)

*******************************************************************
O(2n) exponential time
    ex) Fibonacci
    1,1,2,3,5,8....
    F(n, r){
        if(n <= 0) return 0;
        else if(n == 1) return r[n] =1;
        return r[n] = F(n-1, r) + F(n-2, r);
    }
    time(데이터처리시간)
        ^   *
        |   *
        |  *
        |*
        -------------> data(데이터크기)

*******************************************************************
O(mn) exponential time
*******************************************************************
O(log n)
    binary search
    key = 6
    1,2,3,4,5,6,7,8,9
    6,7,8,9
    이진검색
    가운데 값과 키값 비교
    한번 처리가 진행될때마다 검색해야하는 데이터의 양이 절반으로 뚝뚝 떨어지는 알고리즘
    이진검색
    F(k,arr,s,e){//key, array, start, end
        if(s > e) return -1;
        m = (s + e) / 2;
        if(arr[m] == k) return m;
        else if(arr[m] > k) return F(k, arr, s, m-1);
        else return F(k,arr,m+1,e);
    }
    time(데이터처리시간)
        ^
        |
        |   _ _ _ _
        | /
        -------------> data(데이터크기)

*******************************************************************
O(sqrt(n))
    square root?
    root 100 = 10
    100 = 10 x 10;
    root 9 = 3
    root 4 = 2


